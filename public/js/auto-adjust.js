
import {saveWorld, saveWorldList} from "./save.js"
import {transpose, matmul2, euler_angle_to_rotate_matrix } from "./util.js";

// todo: this module needs a proper name

function AutoAdjust(mouse, header){
    this.mouse = mouse;
    this.header = header;
    var marked_object = null;

    // mark bbox, which will be used as reference-bbox of an object.
    this.mark_bbox=function(box){
        if (box){
            this.marked_object = {
                frame: box.world.frameInfo.frame,
                scene: box.world.frameInfo.scene,
                obj_type: box.obj_type,
                obj_track_id: box.obj_track_id,
                position: box.position,  //todo, copy x,y,z, not object
                scale: box.scale,
                rotation: box.rotation,
            }
    
            console.log(this.marked_object);
    
            this.header.set_ref_obj(this.marked_object);
        }
    };
    
    this.fixRelationToRef = function(box){
        //find ref object in current frame
        let world = box.world;
        let refObj = world.boxes.find(b=>b.obj_track_id == this.marked_object.obj_track_id);
        if (refObj){
            console.log("found ref obj in current frame");

            //compute relative position
            // represent obj in coordinate system of refobj
            
            let coord = euler_angle_to_rotate_matrix(refObj.rotation, {x:0,y:0,z:0});
            let trans = transpose(coord);
            let p = [box.position.x - refObj.position.x, 
                     box.position.y - refObj.position.y, 
                     box.position.z - refObj.position.z, 
                     1];
            let relativePos = matmul2(trans, p, 4);
            let relativeRot = {
                x: box.rotation.x - refObj.rotation.x,
                y: box.rotation.y - refObj.rotation.y,
                z: box.rotation.z - refObj.rotation.z,
            };
            
            let worldList = box.world.data.worldList;
            let saveList = [];
            worldList.forEach(w=>{
                if (w === box.world){
                    //current frame
                    return;
                }
                
                let existedBox = w.boxes.find(b=>b.obj_track_id === box.obj_track_id);
                
                if (existedBox && !existedBox.annotator)
                {
                    // have same objects annotated.
                    // if its generated by machine, lets overwrite it
                    return;
                }

                let refObjInW = w.boxes.find(b=>b.obj_track_id === refObj.obj_track_id);
                if (!refObjInW){
                    // not found refobj in this world, give up
                    return;
                }

                let coord = euler_angle_to_rotate_matrix(refObjInW.rotation, {x:0, y:0, z:0}, 4);

                let rp = matmul2(coord, relativePos, 4);
                let newObjPos = {
                    x: refObjInW.position.x + rp[0],
                    y: refObjInW.position.y + rp[1],
                    z: refObjInW.position.z + rp[2],
                };

                let newObjRot = {
                    x: refObjInW.rotation.x + relativeRot.x,
                    y: refObjInW.rotation.y + relativeRot.y,
                    z: refObjInW.rotation.z + relativeRot.z
                };
                
                let newBox  = w.add_box(newObjPos, 
                    box.scale, 
                    newObjRot, 
                    box.obj_type, 
                    box.obj_track_id);
                newBox.annotator="F";
                w.load_box(newBox);
                console.log("added box in ", w.frameInfo.frame);
                saveList.push(w);
            });

            saveWorldList(saveList);
        }
    };

    this.paste_bbox=function(pos, add_box_on_pos){
    
        if (!pos)
           pos = marked_object.position;
        else
           pos.z = marked_object.position.z;
    
        return  add_box_on_pos(pos);    
    };
    
    
    this.auto_adjust_bbox=function(box, done, on_box_changed){
    
        saveWorld(function(){
            do_adjust(box, on_box_changed);
        });
        let _self =this;
        function do_adjust(box, on_box_changed){
            console.log("auto adjust highlighted bbox");
    
            var xhr = new XMLHttpRequest();
            // we defined the xhr
            
            xhr.onreadystatechange = function () {
                if (this.readyState != 4) return;
            
                if (this.status == 200) {
                    console.log(this.responseText)
                    console.log(box.position);
                    console.log(box.rotation);
    
    
                    var trans_mat = JSON.parse(this.responseText);
    
                    var rotation = Math.atan2(trans_mat[4], trans_mat[0]) + box.rotation.z;
                    var transform = {
                        x: -trans_mat[3],
                        y: -trans_mat[7],
                        z: -trans_mat[11],
                    }
    
                    
                    
                    /*
                    cos  sin    x 
                    -sin cos    y 
                    */
                    var new_pos = {
                        x: Math.cos(-rotation) * transform.x + Math.sin(-rotation) * transform.y,
                        y: -Math.sin(-rotation) * transform.x + Math.cos(-rotation) * transform.y,
                        z: transform.z,
                    };
    
    
                    box.position.x += new_pos.x;
                    box.position.y += new_pos.y;
                    box.position.z += new_pos.z;
                    
                    
    
                    box.scale.x = marked_object.scale.x;
                    box.scale.y = marked_object.scale.y;
                    box.scale.z = marked_object.scale.z;
    
                    box.rotation.z -= Math.atan2(trans_mat[4], trans_mat[0]);
    
                    console.log(box.position);
                    console.log(box.rotation);
    
                    on_box_changed(box);
            
                    _self.header.mark_changed_flag();
    
                    if (done){
                        done();
                    }
                }
            
                // end of state change: it can be after some time (async)
            };
            
            xhr.open('GET', 
                    "/auto_adjust"+"?scene="+marked_object.scene + "&"+
                                "ref_frame=" + marked_object.frame + "&" +
                                "object_id=" + marked_object.obj_track_id + "&" +                           
                                "adj_frame=" + data.world.frameInfo.frame, 
                    true);
            xhr.send();
        }
    };

    this.smart_paste=function(selected_box, add_box_on_pos, saveWorld, on_box_changed){
        var box = selected_box;
        if (!box){
            box = paste_bbox(this.mosue.get_mouse_location_in_world(), add_box_on_pos);
        }
        
        auto_adjust_bbox(box,
                function(){saveWorld();},
                on_box_changed);
    
        this.header.mark_changed_flag();
    };
    
}


export {AutoAdjust}